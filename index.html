<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>저에너지 흐름 유도형 해양쓰레기 차단 — 아이디어4</title>
<style>
  :root{--accent:#0b6;--bg:#f6f9f7;--card:#ffffff;--muted:#666}
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,'Noto Sans KR',sans-serif;background:var(--bg);margin:0;color:#102022;}
  header{background:linear-gradient(90deg,#0b6a4a, #057a6a);color:#fff;padding:20px 16px;}
  header h1{margin:0;font-size:1.4rem;}
  .container{max-width:980px;margin:18px auto;padding:0 16px;}
  .grid{display:grid;grid-template-columns:1fr 320px;gap:16px;}
  .card{background:var(--card);border-radius:10px;padding:14px;box-shadow:0 2px 8px rgba(12,20,18,0.06);}
  .muted{color:var(--muted);font-size:0.95rem}
  nav a{color:#e9fff6;margin-right:12px;text-decoration:none;font-weight:600}
  section h2{margin-top:0}
  /* simulation area */
  #simCanvas{width:100%;height:260px;background:linear-gradient(#bfe8ff,#e6fbff);border-radius:8px;display:block}
  .controls{display:flex;gap:8px;margin-top:10px}
  button{background:var(--accent);border:none;color:#013;padding:8px 10px;border-radius:8px;font-weight:700;cursor:pointer}
  button.alt{background:#ffd;}
  /* sensor box */
  .sensor{display:flex;flex-direction:column;gap:8px}
  .sensor .row{display:flex;justify-content:space-between;align-items:center;padding:8px;border-radius:8px;background:linear-gradient(#fff,#f7fffb);box-shadow:0 1px 3px rgba(0,0,0,0.03)}
  footer{color:#fff;background:#083; padding:12px;text-align:center;border-radius:0 0 10px 10px;margin-top:18px}
  @media(max-width:900px){.grid{grid-template-columns:1fr}}
</style>
</head>
<body>
<header class="card" style="border-radius:0 0 0 0;background:linear-gradient(90deg,#0b6a4a,#058f6a)">
  <div class="container" style="display:flex;justify-content:space-between;align-items:center">
    <div>
      <h1>아이디어4 — 저에너지 흐름 유도형 해양쓰레기 차단</h1>
      <div class="muted">모듈식 차단막 + 센서 기반 모니터링 (시뮬레이션)</div>
    </div>
    <nav>
      <a href="#idea">아이디어</a>
      <a href="#simulation">시뮬레이션</a>
      <a href="#sensors">센서</a>
      <a href="#manual">설치·운영</a>
    </nav>
  </div>
</header>

<main class="container">
  <div class="grid">
    <div>
      <section id="idea" class="card">
        <h2>문제 인식</h2>
        <p>하구와 연안으로 유입되는 쓰레기는 파도·조류에 의해 넓게 확산되어 생태계와 어업에 피해를 주며, 폭우·태풍 시 그 양이 급증한다. 이를 조기 포착·집중적으로 수거하면 생태·경제적 피해를 줄일 수 있다.</p>

        <h2>핵심 아이디어</h2>
        <ol>
          <li>죽방렴 원리: 자연 흐름을 이용해 쓰레기를 모으는 경사형 모듈 보움 설치</li>
          <li>저에너지: 고정식 펌프 불필요 — 조류·파랑을 활용하여 유도</li>
          <li>센서 연계: 수위/유속/탁도 센서 + 간단한 카메라(이미지 샘플링)로 상태 모니터링</li>
        </ol>

        <h2>기대효과</h2>
        <ul>
          <li>쓰레기 유입 초기 포착 → 수거 비용 감소</li>
          <li>생태계 보호 및 관광·어업 피해 완화</li>
          <li>수거된 자원을 재활용·자원화</li>
        </ul>
      </section>

      <section id="simulation" class="card" style="margin-top:12px">
        <h2>간단 시뮬레이션</h2>
        <canvas id="simCanvas"></canvas>
        <div class="controls">
          <button id="toggleBarrier">차단막 닫기</button>
          <button id="spawnTrash">쓰레기 유입 (수동)</button>
          <button id="resetSim" style="background:#f66">리셋</button>
        </div>
        <p class="muted">차단막을 닫으면 유도가 잘 되어 쓰레기가 포집구로 모입니다. (단순 시뮬레이션)</p>
      </section>

      <section id="manual" class="card" style="margin-top:12px">
        <h2>설치·운영(간단 매뉴얼)</h2>
        <ol>
          <li>입구 유속 조사: 조류가 강한 곳과 약한 곳 파악</li>
          <li>모듈 배치: 모듈을 V자 또는 사선으로 설치해 저에너지 구역 생성</li>
          <li>센서 장착: 수심·유속·탁도 센서와 간단한 카메라(사진 주기 업로드)</li>
          <li>정기 수거: 센서 알람 기준(포집량/유속)으로 수거 스케줄 운영</li>
        </ol>
        <h3>간단한 예산 아이디어</h3>
        <p class="muted">재활용 플라스틱으로 부표 제작, 지역 자원봉사와 연계한 수거 파트너십으로 비용 절감</p>
      </section>
    </div>

    <aside class="card">
      <section id="sensors">
        <h2>실시간(가상) 센서</h2>
        <div class="sensor">
          <div class="row"><div>수위 (m)</div><div id="lvl">0.00</div></div>
          <div class="row"><div>유속 (m/s)</div><div id="flow">0.00</div></div>
          <div class="row"><div>탁도 (NTU)</div><div id="turb">0</div></div>
          <div class="row"><div>포집량 (개)</div><div id="load">0</div></div>
        </div>

        <h3 style="margin-top:12px">데이터 그래프 (가상)</h3>
        <canvas id="chart" width="300" height="120" style="width:100%;border-radius:6px;background:#fff"></canvas>

        <h3 style="margin-top:12px">참여·제보</h3>
        <p class="muted">쓰레기 목격 시 아래로 제보해 주세요.</p>
        <p><a href="mailto:example@local.org?subject=해양쓰레기 제보&body=위치%20(위도,경도)%20및%20사진%20첨부">이메일로 제보하기</a></p>
      </section>
    </aside>
  </div>

  <section class="card" style="margin-top:12px">
    <h2>향후 개선 아이디어 (학생이 직접 시도 가능)</h2>
    <ul>
      <li>간단한 이미지 분류: 휴대폰으로 찍은 사진에서 '플라스틱' vs '기타'를 (수동 라벨) 학습하여 수거 우선순위 정하기</li>
      <li>지역 참여 페이지: 자원봉사 수거 이벤트를 등록하고 포인트를 주는 간단 시스템</li>
      <li>데이터 시각화 확장: 실제 관측값을 CSV로 업로드하여 그래프에 반영</li>
    </ul>
  </section>

</main>

<footer>
  © 2025 저에너지 흐름 유도형 차단 프로젝트 — 학생용 데모
</footer>

<script>
/* --- 시뮬레이션 (간단한 물리 모사·애니메이션) --- */
const canvas = document.getElementById('simCanvas');
canvas.width = canvas.clientWidth * devicePixelRatio;
canvas.height = 260 * devicePixelRatio;
const ctx = canvas.getContext('2d');
ctx.scale(devicePixelRatio, devicePixelRatio);

let trash = [];
let barrierClosed = true;
let load = 0;

function spawnTrash(x){
  trash.push({x: x ?? Math.random()* (canvas.clientWidth-40) + 20, y:20 + Math.random()*40, vx: (Math.random()*0.6 + 0.2), vy: 0, size:8 + Math.random()*6});
}
function resetSim(){trash=[];load=0; updateSensors(0.2, 0.4, 3, 0);}

document.getElementById('spawnTrash').onclick = ()=> spawnTrash();
document.getElementById('resetSim').onclick = ()=> { resetSim(); draw(); }
document.getElementById('toggleBarrier').onclick = function(){
  barrierClosed = !barrierClosed;
  this.textContent = barrierClosed ? '차단막 닫기' : '차단막 열기';
}

function drawBarrier(){
  const w = canvas.clientWidth;
  ctx.fillStyle = barrierClosed ? 'rgba(12,90,60,0.85)' : 'rgba(12,90,60,0.35)';
  ctx.beginPath();
  ctx.moveTo(w*0.6, 0);
  ctx.lineTo(w*0.72, 0);
  ctx.lineTo(w*0.62, 200);
  ctx.lineTo(w*0.58,200);
  ctx.closePath();
  ctx.fill();
}

function draw(){
  ctx.clearRect(0,0,canvas.clientWidth,260);
  // water background
  ctx.fillStyle = '#e6fbff';
  ctx.fillRect(0,0,canvas.clientWidth,260);

  // flow arrows
  for(let i=0;i<8;i++){
    ctx.fillStyle = 'rgba(6,60,70,0.08)';
    ctx.beginPath();
    const y = 30 + i*28;
    ctx.moveTo(10 + (i%2)*6, y);
    ctx.lineTo(40 + (i%2)*6, y);
    ctx.lineTo(35 + (i%2)*6, y-4);
    ctx.lineTo(35 + (i%2)*6, y+4);
    ctx.fill();
  }

  drawBarrier();

  // update and draw trash
  for(let i=trash.length-1;i>=0;i--){
    const p = trash[i];
    // if barrier closed, deflect towards right-lower area (the "collection bay" near right)
    if(barrierClosed){
      // if approaching barrier region, push down-right
      if(p.x > canvas.clientWidth*0.55){
        p.vx *= 0.95;
        p.vy += 0.6;
      } else {
        p.vx += 0.02;
      }
    } else {
      // open: let trash pass more
      p.vx += 0.06;
    }
    p.x += p.vx;
    p.y += p.vy;
    // draw
    ctx.fillStyle = '#6b4';
    ctx.beginPath();
    ctx.ellipse(p.x, p.y, p.size, p.size*0.7, 0,0,Math.PI*2);
    ctx.fill();

    // collection bay: bottom-right rectangle
    const bayX = canvas.clientWidth*0.78, bayY = 180, bayW = canvas.clientWidth*0.18, bayH = 70;
    if(p.x > bayX && p.y > bayY){
      trash.splice(i,1);
      load++;
      updateSensors(null,null,null,load);
    }
    // remove if out of bounds
    if(p.x > canvas.clientWidth + 40 || p.y > 300) trash.splice(i,1);
  }

  // draw collection bay
  ctx.fillStyle = 'rgba(200,120,40,0.12)';
  ctx.fillRect(canvas.clientWidth*0.78,180,canvas.clientWidth*0.18,70);
  ctx.fillStyle = '#c96';
  ctx.fillText('포집구', canvas.clientWidth*0.78 + 8, 200);

  requestAnimationFrame(draw);
}
draw();

// spawn periodic trash to simulate inflow
setInterval(()=>{ if(Math.random()<0.7) spawnTrash(); }, 1500);

/* --- 센서 가상 데이터 및 간단 그래프 --- */
const lvlEl = document.getElementById('lvl'), flowEl = document.getElementById('flow'), turbEl = document.getElementById('turb'), loadEl = document.getElementById('load');
const chart = document.getElementById('chart'), cctx = chart.getContext('2d');
let chartData = [];

function updateSensors(lvl, flow, turb, ld){
  // if null => small random drift
  const prev = chartData.length ? chartData[chartData.length-1] : {lvl:0.2,flow:0.4,turb:3,load:0};
  const nl = lvl ?? Math.max(0.1, prev.lvl + (Math.random()-0.45)*0.02);
  const nf = flow ?? Math.max(0.05, prev.flow + (Math.random()-0.45)*0.03);
  const nt = turb ?? Math.max(0, Math.round(prev.turb + (Math.random()-0.45)*0.8));
  const nlod = ld ?? prev.load;
  chartData.push({t:Date.now(), lvl:nl, flow:nf, turb:nt, load:nlod});
  if(chartData.length>20) chartData.shift();
  // update UI
  lvlEl.textContent = nl.toFixed(2);
  flowEl.textContent = nf.toFixed(2);
  turbEl.textContent = nt;
  loadEl.textContent = nlod;
  drawChart();
}
function drawChart(){
  cctx.clearRect(0,0,chart.width,chart.height);
  // draw lvl line
  if(chartData.length<2) return;
  const pad = 6;
  const w = chart.width - pad*2, h = chart.height - pad*2;
  // get max for scaling (use flow as example)
  const maxFlow = Math.max(...chartData.map(d=>d.flow))*1.3;
  cctx.beginPath();
  chartData.forEach((d,i)=>{
    const x = pad + (i/(chartData.length-1))*w;
    const y = pad + h*(1 - (d.flow/maxFlow));
    if(i===0) cctx.moveTo(x,y); else cctx.lineTo(x,y);
  });
  cctx.strokeStyle = '#067'; cctx.lineWidth = 2; cctx.stroke();
  cctx.fillStyle = '#044'; cctx.fillText('유속 (m/s) — 가상', 8, 12);
}
setInterval(()=> updateSensors(), 1200);

/* init */
resetSim();
</script>
</body>
</html>
